# Covariant Script Parser Generator: Formatter of Extended CovScript(ECS Lang) v1.1.1
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Copyright (C) 2017-2022 Michael Lee(李登淳)
#
# Email:   lee@unicov.cn, mikecovlee@163.com
# Github:  https://github.com/mikecovlee
# Website: http://covscript.org.cn
#
# Generated by CovScript AST Visitor Generator

package ecs_style

import parsergen

class main
    var target = system.out
    var indent = -1
    function print_indent()
        foreach i in range(indent) do target.print('\t')
    end
    function visit_declaration(nodes)
        print_indent()
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "prep-stmt")
                matched = true
                # Recursive Visit prep-stmt
                this.visit_prep_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "namespace-stmt")
                matched = true
                # Recursive Visit namespace-stmt
                this.visit_namespace_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-stmt")
                matched = true
                # Recursive Visit var-stmt
                this.visit_var_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "using-stmt")
                matched = true
                # Recursive Visit using-stmt
                this.visit_using_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "function-stmt")
                matched = true
                # Recursive Visit function-stmt
                this.visit_function_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "class-stmt")
                matched = true
                # Recursive Visit class-stmt
                this.visit_class_stmt(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_module_list(nodes)
        var idx = 0
        # Visit id token
        target.print(nodes[idx++].data)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
            # Visit term "."
            ++idx; target.print(".")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*")
                    matched = true
                    # Visit term "*"
                    ++idx; target.print("*")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "module-list")
                    matched = true
                    # Recursive Visit module-list
                    this.visit_module_list(nodes[idx++].nodes)
                end
                if !matched
                	# Error
                	return
                end
            end
        end
    end
    function visit_expr(nodes)
        var idx = 0
        # Recursive Visit single-expr
        this.visit_single_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
    end
    function visit_block_stmt(nodes)
        var idx = 0
        # Visit term "block"
        ++idx; target.print("block ")
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_endblock(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "end-stmt")
                matched = true
                # Recursive Visit end-stmt
                this.visit_end_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "else-stmt")
                matched = true
                # Recursive Visit else-stmt
                this.visit_else_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "until-stmt")
                matched = true
                # Recursive Visit until-stmt
                this.visit_until_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "catch-stmt")
                matched = true
                # Recursive Visit catch-stmt
                this.visit_catch_stmt(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_stmts(nodes)
        var idx = 0
        ++indent
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "statement")
            # Recursive Visit statement
            this.visit_statement(nodes[idx++].nodes)
            # Repeat
            while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                # Visit endl token
                ++idx
            end
        end
        --indent
    end
    function visit_begin(nodes)
        var idx = 0
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
    end
    function visit_statement(nodes)
        print_indent()
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "prep-stmt")
                matched = true
                # Recursive Visit prep-stmt
                this.visit_prep_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "package-stmt")
                matched = true
                # Recursive Visit package-stmt
                this.visit_package_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "import-stmt")
                matched = true
                # Recursive Visit import-stmt
                this.visit_import_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-stmt")
                matched = true
                # Recursive Visit var-stmt
                this.visit_var_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "block-stmt")
                matched = true
                # Recursive Visit block-stmt
                this.visit_block_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "namespace-stmt")
                matched = true
                # Recursive Visit namespace-stmt
                this.visit_namespace_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "using-stmt")
                matched = true
                # Recursive Visit using-stmt
                this.visit_using_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "if-stmt")
                matched = true
                # Recursive Visit if-stmt
                this.visit_if_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-stmt")
                matched = true
                # Recursive Visit switch-stmt
                this.visit_switch_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "while-stmt")
                matched = true
                # Recursive Visit while-stmt
                this.visit_while_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "loop-stmt")
                matched = true
                # Recursive Visit loop-stmt
                this.visit_loop_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "for-stmt")
                matched = true
                # Recursive Visit for-stmt
                this.visit_for_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "foreach-stmt")
                matched = true
                # Recursive Visit foreach-stmt
                this.visit_foreach_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "control-stmt")
                matched = true
                # Recursive Visit control-stmt
                this.visit_control_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "function-stmt")
                matched = true
                # Recursive Visit function-stmt
                this.visit_function_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "return-stmt")
                matched = true
                # Recursive Visit return-stmt
                this.visit_return_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "try-stmt")
                matched = true
                # Recursive Visit try-stmt
                this.visit_try_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "throw-stmt")
                matched = true
                # Recursive Visit throw-stmt
                this.visit_throw_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "class-stmt")
                matched = true
                # Recursive Visit class-stmt
                this.visit_class_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr-stmt")
                matched = true
                # Recursive Visit expr-stmt
                this.visit_expr_stmt(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_bind_list(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Visit id token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "...")
                matched = true
                # Visit ... token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-bind")
                matched = true
                # Recursive Visit var-bind
                this.visit_var_bind(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_for_stmt(nodes)
        var idx = 0
        # Visit term "for"
        ++idx; target.print("for ")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-def")
            # Recursive Visit var-def
            this.visit_var_def(nodes[idx++].nodes)
        end
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
                matched = true
                # Visit term ";"
                ++idx; target.print("; ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                matched = true
                # Visit term ","
                ++idx; target.print(", ")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "basic-expr")
            # Recursive Visit basic-expr
            this.visit_basic_expr(nodes[idx++].nodes)
        end
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
                matched = true
                # Visit term ";"
                ++idx; target.print("; ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                matched = true
                # Visit term ","
                ++idx; target.print(", ")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "basic-expr")
            # Recursive Visit basic-expr
            this.visit_basic_expr(nodes[idx++].nodes)
        end
        # Recursive Visit for-body
        this.visit_for_body(nodes[idx++].nodes)
    end
    function visit_for_body(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "do")
                matched = true
                # Visit term "do"
                ++idx; target.print(" do ")
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
                # Recursive Visit endline
                this.visit_endline(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                matched = true
                # Visit endl token
                ++idx; target.println("")
                # Recursive Visit stmts
                this.visit_stmts(nodes[idx++].nodes)
                # Visit term "end"
                print_indent()
                target.println("end")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_class_stmt(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "class")
                matched = true
                # Visit term "class"
                ++idx; target.print("class ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "struct")
                matched = true
                # Visit term "struct"
                ++idx; target.print("struct ")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Visit id token
        target.print(nodes[idx++].data)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "extends")
            # Visit term "extends"
            ++idx; target.print(" extends ")
            # Recursive Visit visit-expr
            this.visit_visit_expr(nodes[idx++].nodes)
        end
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit decl-stmts
        this.visit_decl_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_single_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "lambda-expr")
                matched = true
                # Recursive Visit lambda-expr
                this.visit_lambda_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "basic-expr")
                matched = true
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_capture_list(nodes)
        var idx = 0
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
            # Visit term "="
            ++idx; target.print("=")
        end
        # Visit id token
        target.print(nodes[idx++].data)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit capture-list
            this.visit_capture_list(nodes[idx++].nodes)
        end
    end
    function visit_catch_stmt(nodes)
        var idx = 0
        # Visit term "catch"
        print_indent()
        ++idx; target.print("catch ")
        # Visit id token
        target.print(nodes[idx++].data)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
            # Visit term ":"
            ++idx; target.print(":")
            # Recursive Visit visit-expr
            this.visit_visit_expr(nodes[idx++].nodes)
        end
        # Visit endl token
        target.print(nodes[idx++].data)
    end
    function visit_else_stmt(nodes)
        var idx = 0
        # Visit term "else"
        print_indent()
        ++idx; target.print("else")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "if")
            # Visit term "if"
            ++idx; target.print(" if ")
            # Recursive Visit basic-expr
            this.visit_basic_expr(nodes[idx++].nodes)
        end
        # Visit endl token
        target.println("")
    end
    function visit_unary_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "unary-op")
                matched = true
                # Recursive Visit unary-op
                this.visit_unary_op(nodes[idx++].nodes)
                # Recursive Visit unary-expr
                this.visit_unary_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "new" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "gcnew")
                matched = true
                # Condition
                block
                    var matched = false
                    if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "new")
                        matched = true
                        # Visit term "new"
                        ++idx; target.print("new ")
                    end
                    if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "gcnew")
                        matched = true
                        # Visit term "gcnew"
                        ++idx; target.print("gcnew ")
                    end
                    if !matched
                    	# Error
                    	return
                    end
                end
                # Recursive Visit unary-expr
                this.visit_unary_expr(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "array")
                    # Recursive Visit array
                    this.visit_array(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "prim-expr")
                matched = true
                # Recursive Visit prim-expr
                this.visit_prim_expr(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "postfix-expr")
                    # Recursive Visit postfix-expr
                    this.visit_postfix_expr(nodes[idx++].nodes)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_constant(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "num")
                matched = true
                # Visit num token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "null")
                matched = true
                # Visit term "null"
                ++idx; target.print("null")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "true")
                matched = true
                # Visit term "true"
                ++idx; target.print("true")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "false")
                matched = true
                # Visit term "false"
                ++idx; target.print("false")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_bind(nodes)
        var idx = 0
        # Visit term "("
        ++idx; target.print("(")
        # Recursive Visit var-bind-list
        this.visit_var_bind_list(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit var-bind-list
            this.visit_var_bind_list(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; target.print(")")
    end
    function visit_postfix_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "++")
                matched = true
                # Visit term "++"
                ++idx; target.print("++")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "--")
                matched = true
                # Visit term "--"
                ++idx; target.print("--")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "...")
                matched = true
                # Visit term "..."
                ++idx; target.print("...")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "postfix-expr")
            # Recursive Visit postfix-expr
            this.visit_postfix_expr(nodes[idx++].nodes)
        end
    end
    function visit_lambda_expr(nodes)
        var idx = 0
        # Visit term "["
        ++idx; target.print("[")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "capture-list")
            # Recursive Visit capture-list
            this.visit_capture_list(nodes[idx++].nodes)
        end
        # Visit term "]"
        ++idx; target.print("]")
        # Visit term "("
        ++idx; target.print("(")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "argument-list")
            # Recursive Visit argument-list
            this.visit_argument_list(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; target.print(")")
        # Recursive Visit lambda-body
        this.visit_lambda_body(nodes[idx++].nodes)
    end
    function visit_relat_expr(nodes)
        var idx = 0
        # Recursive Visit add-expr
        this.visit_add_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">=" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<=")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">")
                    matched = true
                    # Visit term ">"
                    ++idx; target.print(" > ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<")
                    matched = true
                    # Visit term "<"
                    ++idx; target.print(" < ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ">=")
                    matched = true
                    # Visit term ">="
                    ++idx; target.print(" >= ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "<=")
                    matched = true
                    # Visit term "<="
                    ++idx; target.print(" <= ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit relat-expr
            this.visit_relat_expr(nodes[idx++].nodes)
        end
    end
    function visit_import_stmt(nodes)
        var idx = 0
        # Visit term "import"
        ++idx; target.print("import ")
        # Recursive Visit import-list
        this.visit_import_list(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_asi_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
                matched = true
                # Visit term "="
                ++idx; target.print(" = ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":=")
                matched = true
                # Visit term ":="
                ++idx; target.print(" := ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "+=")
                matched = true
                # Visit term "+="
                ++idx; target.print(" += ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-=")
                matched = true
                # Visit term "-="
                ++idx; target.print(" -= ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*=")
                matched = true
                # Visit term "*="
                ++idx; target.print(" *= ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "/=")
                matched = true
                # Visit term "/="
                ++idx; target.print(" /= ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "%=")
                matched = true
                # Visit term "%="
                ++idx; target.print(" %= ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "^=")
                matched = true
                # Visit term "^="
                ++idx; target.print(" ^= ")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_lambda_body(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "{")
                matched = true
                # Visit term "{"
                ++idx; target.println("{")
                ++indent
                # Repeat
                while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "statement")
                    # Recursive Visit statement
                    this.visit_statement(nodes[idx++].nodes)
                    # Repeat
                    while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                        # Visit endl token
                        ++idx
                    end
                end
                --indent
                # Visit term "}"
                ++idx; target.print("}")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "->")
                matched = true
                # Visit term "->"
                ++idx; target.print("->")
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_prep_stmt(nodes)
        var idx = 0
        # Visit prep token
        link prep = nodes[idx++].data
        if prep != "@begin" && prep != "@end"
            target.println(prep)
        end
    end
    function visit_argument_list(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "...")
                matched = true
                # Visit term "..."
                ++idx; target.print("...")
                # Visit id token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "=")
                    # Visit term "="
                    ++idx; target.print("=")
                end
                # Visit id token
                target.print(nodes[idx++].data)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
                    # Visit term ":"
                    ++idx; target.print(":")
                    # Recursive Visit visit-expr
                    this.visit_visit_expr(nodes[idx++].nodes)
                end
                # Repeat
                while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
                    # Visit term ","
                    ++idx; target.print(", ")
                    # Recursive Visit argument-list
                    this.visit_argument_list(nodes[idx++].nodes)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_visit_expr(nodes)
        var idx = 0
        # Recursive Visit object
        this.visit_object(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "->" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "->")
                    matched = true
                    # Visit term "->"
                    ++idx; target.print("->")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ".")
                    matched = true
                    # Visit term "."
                    ++idx; target.print(".")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit visit-expr
            this.visit_visit_expr(nodes[idx++].nodes)
        end
    end
    function visit_basic_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-bind")
                matched = true
                # Recursive Visit var-bind
                this.visit_var_bind(nodes[idx++].nodes)
                # Visit term "="
                ++idx; target.print(" = ")
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "cond-expr")
                matched = true
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "asi-op")
                    # Recursive Visit asi-op
                    this.visit_asi_op(nodes[idx++].nodes)
                    # Recursive Visit single-expr
                    this.visit_single_expr(nodes[idx++].nodes)
                end
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_mul_expr(nodes)
        var idx = 0
        # Recursive Visit unary-expr
        this.visit_unary_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "/" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "%" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "^")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*")
                    matched = true
                    # Visit term "*"
                    ++idx; target.print("*")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "/")
                    matched = true
                    # Visit term "/"
                    ++idx; target.print("/")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "%")
                    matched = true
                    # Visit term "%"
                    ++idx; target.print("%")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "^")
                    matched = true
                    # Visit term "^"
                    ++idx; target.print("^")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit mul-expr
            this.visit_mul_expr(nodes[idx++].nodes)
        end
    end
    function visit_switch_stmts(nodes)
        var idx = 0
        ++indent
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-case" || typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-default")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-case")
                    matched = true
                    # Recursive Visit switch-case
                    this.visit_switch_case(nodes[idx++].nodes)
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "switch-default")
                    matched = true
                    # Recursive Visit switch-default
                    this.visit_switch_default(nodes[idx++].nodes)
                end
                if !matched
                	# Error
                	return
                end
            end
            # Repeat
            while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                # Visit endl token
                ++idx
            end
        end
        --indent
    end
    function visit_index(nodes)
        var idx = 0
        # Visit term "["
        ++idx; target.print("[")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit term "]"
        ++idx; target.print("]")
    end
    function visit_var_list(nodes)
        var idx = 0
        # Visit id token
        target.print(nodes[idx++].data)
        # Visit term "="
        ++idx; target.print(" = ")
        # Recursive Visit single-expr
        this.visit_single_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit var-list
            this.visit_var_list(nodes[idx++].nodes)
        end
    end
    function visit_if_stmt(nodes)
        var idx = 0
        # Visit term "if"
        ++idx; target.print("if ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "else-stmt")
            # Recursive Visit else-stmt
            this.visit_else_stmt(nodes[idx++].nodes)
            # Recursive Visit stmts
            this.visit_stmts(nodes[idx++].nodes)
        end
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_switch_case(nodes)
        var idx = 0
        # Visit term "case"
        print_indent()
        ++idx; target.print("case ")
        # Recursive Visit logic-or-expr
        this.visit_logic_or_expr(nodes[idx++].nodes)
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_foreach_stmt(nodes)
        var idx = 0
        # Visit term "foreach"
        ++idx; target.print("foreach ")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
            # Visit id token
            target.print(nodes[idx++].data + " ")
        end
        # Visit term "in"
        ++idx; target.print("in ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Recursive Visit for-body
        this.visit_for_body(nodes[idx++].nodes)
    end
    function visit_var_stmt(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "var")
                matched = true
                # Visit term "var"
                ++idx; target.print("var ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "link")
                matched = true
                # Visit term "link"
                ++idx; target.print("link ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "constant")
                matched = true
                # Visit term "constant"
                ++idx; target.print("constant ")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Recursive Visit var-def
        this.visit_var_def(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_object(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "array")
                matched = true
                # Recursive Visit array
                this.visit_array(nodes[idx++].nodes)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
                    # Recursive Visit index
                    this.visit_index(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "str")
                matched = true
                # Visit str token
                target.print(nodes[idx++].data)
                # Optional
                if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
                    # Recursive Visit index
                    this.visit_index(nodes[idx++].nodes)
                end
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "local")
                matched = true
                # Visit term "local"
                ++idx; target.print("local")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "global")
                matched = true
                # Visit term "global"
                ++idx; target.print("global")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "element")
                matched = true
                # Recursive Visit element
                this.visit_element(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "char")
                matched = true
                # Visit char token
                target.print(nodes[idx++].data)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_using_stmt(nodes)
        var idx = 0
        # Visit term "using"
        ++idx; target.print("using ")
        # Recursive Visit using-list
        this.visit_using_list(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_add_expr(nodes)
        var idx = 0
        # Recursive Visit mul-expr
        this.visit_mul_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "+" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "+")
                    matched = true
                    # Visit term "+"
                    ++idx; target.print(" + ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-")
                    matched = true
                    # Visit term "-"
                    ++idx; target.print(" - ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit add-expr
            this.visit_add_expr(nodes[idx++].nodes)
        end
    end
    function visit_prim_expr(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "visit-expr")
                matched = true
                # Recursive Visit visit-expr
                this.visit_visit_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "constant")
                matched = true
                # Recursive Visit constant
                this.visit_constant(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_return_stmt(nodes)
        var idx = 0
        # Visit term "return"
        ++idx; target.print("return")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            target.print(" ")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_while_stmt(nodes)
        var idx = 0
        # Visit term "while"
        ++idx; target.print("while ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_switch_stmt(nodes)
        var idx = 0
        # Visit term "switch"
        ++idx; target.print("switch ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit switch-stmts
        this.visit_switch_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_element(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "id")
                matched = true
                # Visit id token
                target.print(nodes[idx++].data)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "(")
                matched = true
                # Visit term "("
                ++idx; target.print("(")
                # Recursive Visit single-expr
                this.visit_single_expr(nodes[idx++].nodes)
                # Visit term ")"
                ++idx; target.print(")")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "fcall" || typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "fcall")
                    matched = true
                    # Recursive Visit fcall
                    this.visit_fcall(nodes[idx++].nodes)
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "index")
                    matched = true
                    # Recursive Visit index
                    this.visit_index(nodes[idx++].nodes)
                end
                if !matched
                	# Error
                	return
                end
            end
        end
    end
    function visit_namespace_stmt(nodes)
        var idx = 0
        # Visit term "namespace"
        ++idx; target.print("namespace ")
        # Visit id token
        target.print(nodes[idx++].data)
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit decl-stmts
        this.visit_decl_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_array(nodes)
        var idx = 0
        # Visit term "{"
        ++idx; target.print("{")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
        # Visit term "}"
        ++idx; target.print("}")
    end
    function visit_switch_default(nodes)
        var idx = 0
        # Visit term "default"
        print_indent()
        ++idx; target.print("default")
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_using_list(nodes)
        var idx = 0
        # Recursive Visit module-list
        this.visit_module_list(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit using-list
            this.visit_using_list(nodes[idx++].nodes)
        end
    end
    function visit_cond_expr(nodes)
        var idx = 0
        # Recursive Visit logic-or-expr
        this.visit_logic_or_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "cond-postfix")
            # Recursive Visit cond-postfix
            this.visit_cond_postfix(nodes[idx++].nodes)
        end
    end
    function visit_cond_postfix(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "?")
                matched = true
                # Visit term "?"
                ++idx; target.print(" ? ")
                # Recursive Visit logic-or-expr
                this.visit_logic_or_expr(nodes[idx++].nodes)
                # Visit term ":"
                ++idx; target.print(" : ")
                # Recursive Visit cond-expr
                this.visit_cond_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ":")
                matched = true
                # Visit term ":"
                ++idx; target.print(" : ")
                # Recursive Visit logic-or-expr
                this.visit_logic_or_expr(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_decl_stmts(nodes)
        var idx = 0
        ++indent
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "declaration")
            # Recursive Visit declaration
            this.visit_declaration(nodes[idx++].nodes)
            # Repeat
            while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                # Visit endl token
                ++idx
            end
        end
        --indent
    end
    function visit_import_list(nodes)
        var idx = 0
        # Recursive Visit module-list
        this.visit_module_list(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "as")
            # Visit term "as"
            ++idx; target.print(" as ")
            # Visit id token
            target.print(nodes[idx++].data)
        end
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ",")
            # Visit term ","
            ++idx; target.print(", ")
            # Recursive Visit import-list
            this.visit_import_list(nodes[idx++].nodes)
        end
    end
    function visit_throw_stmt(nodes)
        var idx = 0
        # Visit term "throw"
        ++idx; target.print("throw")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            target.print(" ")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_endline(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                matched = true
                # Visit endl token
                ++idx; target.println("")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == ";")
                matched = true
                # Visit term ";"
                ++idx; target.println(";")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_try_stmt(nodes)
        var idx = 0
        # Visit term "try"
        ++idx; target.print("try ")
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        # Repeat
        while idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "catch-stmt")
            # Recursive Visit catch-stmt
            this.visit_catch_stmt(nodes[idx++].nodes)
            # Recursive Visit stmts
            this.visit_stmts(nodes[idx++].nodes)
        end
        # Visit term "end"
        print_indent()
        target.println("end")
    end
    function visit_function_stmt(nodes)
        var idx = 0
        # Visit term "function"
        ++idx; target.print("function ")
        # Visit id token
        target.print(nodes[idx++].data)
        # Visit term "("
        ++idx; target.print("(")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "argument-list")
            # Recursive Visit argument-list
            this.visit_argument_list(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; target.print(")")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "override")
            # Visit term "override"
            ++idx; target.print(" override")
        end
        # Recursive Visit function-body
        this.visit_function_body(nodes[idx++].nodes)
    end
    function visit_function_body(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "{")
                matched = true
                # Visit term "{"
                ++idx; target.println("{")
                # Recursive Visit stmts
                this.visit_stmts(nodes[idx++].nodes)
                # Visit term "}"
                ++idx; target.println("}")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].type == "endl")
                matched = true
                # Visit endl token
                ++idx; target.println("")
                # Recursive Visit stmts
                this.visit_stmts(nodes[idx++].nodes)
                # Visit term "end"
                print_indent()
                target.println("end")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_loop_stmt(nodes)
        var idx = 0
        # Visit term "loop"
        ++idx; target.print("loop")
        # Visit endl token
        ++idx; target.println("")
        # Recursive Visit stmts
        this.visit_stmts(nodes[idx++].nodes)
        print_indent()
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "until-stmt")
                matched = true
                # Recursive Visit until-stmt
                this.visit_until_stmt(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "end")
                matched = true
                # Visit term "end"
                target.println("end")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_control_stmt(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "break")
                matched = true
                # Visit term "break"
                ++idx; target.print("break")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "continue")
                matched = true
                # Visit term "continue"
                ++idx; target.print("continue")
            end
            if !matched
            	# Error
            	return
            end
        end
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_logic_or_expr(nodes)
        var idx = 0
        # Recursive Visit logic-and-expr
        this.visit_logic_and_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "||" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "or")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "||")
                    matched = true
                    # Visit term "||"
                    ++idx; target.print(" || ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "or")
                    matched = true
                    # Visit term "or"
                    ++idx; target.print(" or ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit logic-or-expr
            this.visit_logic_or_expr(nodes[idx++].nodes)
        end
    end
    function visit_package_stmt(nodes)
        var idx = 0
        # Visit term "package"
        ++idx; target.print("package ")
        # Visit id token
        target.print(nodes[idx++].data)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_until_stmt(nodes)
        var idx = 0
        # Visit term "until"
        ++idx; target.print("until ")
        # Recursive Visit basic-expr
        this.visit_basic_expr(nodes[idx++].nodes)
        # Visit endl token
        target.println("")
    end
    function visit_equal_expr(nodes)
        var idx = 0
        # Recursive Visit relat-expr
        this.visit_relat_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "==" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "!=")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "==")
                    matched = true
                    # Visit term "=="
                    ++idx; target.print(" == ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "!=")
                    matched = true
                    # Visit term "!="
                    ++idx; target.print(" != ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit equal-expr
            this.visit_equal_expr(nodes[idx++].nodes)
        end
    end
    function visit_unary_op(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "typeid")
                matched = true
                # Visit term "typeid"
                ++idx; target.print("typeid ")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "++")
                matched = true
                # Visit term "++"
                ++idx; target.print("++")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "--")
                matched = true
                # Visit term "--"
                ++idx; target.print("--")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "*")
                matched = true
                # Visit term "*"
                ++idx; target.print("*")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "&")
                matched = true
                # Visit term "&"
                ++idx; target.print("&")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "-")
                matched = true
                # Visit term "-"
                ++idx; target.print("-")
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "!")
                matched = true
                # Visit term "!"
                ++idx; target.print("!")
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_var_def(nodes)
        var idx = 0
        # Condition
        block
            var matched = false
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-bind")
                matched = true
                # Recursive Visit var-bind
                this.visit_var_bind(nodes[idx++].nodes)
                # Visit term "="
                ++idx; target.print(" = ")
                # Recursive Visit basic-expr
                this.visit_basic_expr(nodes[idx++].nodes)
            end
            if !matched && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "var-list")
                matched = true
                # Recursive Visit var-list
                this.visit_var_list(nodes[idx++].nodes)
            end
            if !matched
            	# Error
            	return
            end
        end
    end
    function visit_expr_stmt(nodes)
        var idx = 0
        # Recursive Visit expr
        this.visit_expr(nodes[idx++].nodes)
        # Recursive Visit endline
        this.visit_endline(nodes[idx++].nodes)
    end
    function visit_fcall(nodes)
        var idx = 0
        # Visit term "("
        ++idx; target.print("(")
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.syntax_tree && nodes[idx].root == "expr")
            # Recursive Visit expr
            this.visit_expr(nodes[idx++].nodes)
        end
        # Visit term ")"
        ++idx; target.print(")")
    end
    function visit_logic_and_expr(nodes)
        var idx = 0
        # Recursive Visit equal-expr
        this.visit_equal_expr(nodes[idx++].nodes)
        # Optional
        if idx < nodes.size && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "&&" || typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "and")
            # Condition
            block
                var matched = false
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "&&")
                    matched = true
                    # Visit term "&&"
                    ++idx; target.print(" && ")
                end
                if !matched && (typeid nodes[idx] == typeid parsergen.token_type && nodes[idx].data == "and")
                    matched = true
                    # Visit term "and"
                    ++idx; target.print(" and ")
                end
                if !matched
                	# Error
                	return
                end
            end
            # Recursive Visit logic-and-expr
            this.visit_logic_and_expr(nodes[idx++].nodes)
        end
    end
    function run(os, ast)
        this.target = os
        this.visit_begin(ast.nodes)
    end
end
