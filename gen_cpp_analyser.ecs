import ecs_parser, parsergen

constant syntax_type = parsergen.syntax_type

class generator
    var indent_width = 4
    var indent_count = 0
    var class_name = "parser"
    var parser = null
    var syntax = null
    var ofs = null
    function print_indent()
        foreach i in range(indent_count*indent_width) do ofs.print(" ")
    end
    function println(msg)
        foreach i in range(indent_count*indent_width) do ofs.print(" ")
        ofs.println(msg)
    end
    function get_legal_name(id)
        var name = id
        for i = 0, i < name.size, ++i
            if name[i] == '-'
                name.assign(i, '_')
            end
        end
        return move(name)
    end
    function gen_syntax_impl(name, seq)
        println("parse_state " + class_name + "::match_" + get_legal_name(name) + "()")
        println("{")
        ++indent_count
        println("push_stage(\"" + name + "\");")
        println("parse_state state = parse_state::null;")
        foreach it in seq
            switch it.type
                case syntax_type.token
                    println("// Terminal Symbol <" + it.data + ">")
                    println("state = match_token(\"" + it.data + "\");")
                    println("if (state != parse_state::accept) return state;")
                end
                case syntax_type.term
                    println("// Terminal Symbol " + it.data)
                    println("state = match_term(\"" + it.data + "\");")
                    println("if (state != parse_state::accept) return state;")
                end
                case syntax_type.ref
                    println("// Non-terminal Symbol " + it.data)
                    println("state = match_" + get_legal_name(it.data) + "();")
                    println("if (state == parse_state::accept) {")
                    ++indent_count
                    println("accept();")
                    --indent_count
                    println("} else {")
                    ++indent_count
                    println("pop_stage();")
                    println("return state;")
                    --indent_count
                    println("}")
                end
                case syntax_type.nlook
                    println("// NLook Block")
                    println("state = match_" + get_legal_name(it.data) + "();")
                    println("pop_stage();")
                    println("switch (state) {")
                    println("case parse_state::accept:")
                    ++indent_count
                    println("return parse_state::reject;")
                    --indent_count
                    println("case parse_state::eof:")
                    ++indent_count
                    println("return parse_state::eof;")
                    --indent_count
                    println("}")
                end
                case syntax_type.repeat
                    println("// Repeat Block")
                    println("while (true) {")
                    ++indent_count
                    println("state = match_" + it.data + "();")
                    println("if (state != parse_state::accept) {")
                    ++indent_count
                    println("pop_stage();")
                    println("break;")
                    --indent_count
                    println("} else {")
                    ++indent_count
                    println("merge();")
                    --indent_count
                    println("}")
                    --indent_count
                    println("}")
                end
                case syntax_type.opt
                    println("// Option Block")
                    println("state = match_" + it.data + "();")
                    println("if (state != parse_state::accept) {")
                    ++indent_count
                    println("pop_stage();")
                    --indent_count
                    println("} else {")
                    ++indent_count
                    println("merge();")
                    --indent_count
                    println("}")
                end
                case syntax_type.cond
                    println("// Condition Block")
                    println("{")
                    ++indent_count
                    println("bool cond_matched = false;")
                    foreach cond in it.data
                        println("if (!cond_matched) {")
                        ++indent_count
                        println("state = match_" + cond.data + "();")
                        println("switch (state) {")
                        println("case parse_state::accept:")
                        ++indent_count
                        println("cond_matched = true;")
                        println("merge();")
                        println("break;")
                        --indent_count
                        println("case parse_state::reject:")
                        ++indent_count
                        println("pop_stage();")
                        println("break;")
                        --indent_count
                        println("case parse_state::eof:")
                        ++indent_count
                        println("pop_stage();")
                        println("return parse_state::eof;")
                        --indent_count
                        println("}")
                        --indent_count
                        println("}")
                    end
                    println("if (!cond_matched)")
                    ++indent_count
                    println("return parse_state::reject;")
                    --indent_count
                    --indent_count
                    println("}")
                end
            end
        end
        println("return parse_state::accept;")
        --indent_count
        println("}")
    end
    function replace_block(supp_stx, block_id, rule_name, rule_seq)
        foreach it in rule_seq
            switch it.type
                case syntax_type.nlook
                    ++block_id
                    ++block_id
                    var name = get_legal_name(rule_name) + "_nlook_block_" + (block_id)
                    replace_block(supp_stx, block_id, rule_name, it.data)
                    supp_stx.insert(name, it.data)
                    it.data = name
                end
                case syntax_type.repeat
                    ++block_id
                    var name = get_legal_name(rule_name) + "_repeat_block_" + (block_id)
                    replace_block(supp_stx, block_id, rule_name, it.data)
                    supp_stx.insert(name, it.data)
                    it.data = name
                end
                case syntax_type.opt
                    ++block_id
                    var name = get_legal_name(rule_name) + "_option_block_" + (block_id)
                    replace_block(supp_stx, block_id, rule_name, it.data)
                    supp_stx.insert(name, it.data)
                    it.data = name
                end
                case syntax_type.cond
                    ++block_id
                    var cond_id = 0
                    foreach seq in it.data
                        var name = get_legal_name(rule_name) + "_cond_block_" + (block_id) + "_" + (++cond_id)
                        replace_block(supp_stx, block_id, rule_name, seq.data)
                        supp_stx.insert(name, seq.data)
                        seq.data = name
                    end
                end
            end
        end
    end
    function run(stx)
        # parser = new parsergen.parser_type
        # parser.init(stx)
        syntax = stx
        var supp_stx = new hash_map
        foreach rule in syntax
            var block_id = 0
            replace_block(supp_stx, block_id, rule.first, rule.second)
        end
        foreach it in supp_stx
            syntax.insert(it.first, it.second)
        end
        println("// Generated by CovScript Parsergen")
        println("// Date: " + to_string(runtime.local_time()))
        println("#include <parsergen.hpp>")
        println("namespace parsergen")
        println("{")
        ++indent_count
        if syntax.exist("ignore")
            println("class parser : public parsergen::parser_with_ign")
        else
            println("class parser : public parsergen::parser_type")
        end
        println("{")
        ++indent_count
        foreach it in syntax
            println("parse_state match_" + get_legal_name(it.first) + "();")
        end
        --indent_count
        println("};")
        foreach it in syntax
            gen_syntax_impl(it.first, it.second)
        end
        --indent_count
        println("}")
    end
end

var obj = new generator
obj.ofs = iostream.ofstream("./a.cpp")
obj.run(ecs_parser.grammar.stx)