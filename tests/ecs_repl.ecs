import parsergen_debug as parsergen, ecs_parser

function compress_ast(n)
    foreach it in n.nodes
        while typeid it == typeid parsergen.syntax_tree && it.nodes.size == 1
            it = it.nodes.front
        end
        if typeid it == typeid parsergen.syntax_tree
            compress_ast(it)
        else
            if it.type == "endl"
                it.data = "\\n"
            end
        end
    end
end

class repl
    var syntax_stages = {"ignore", "nlook", "repeat", "optional", "cond_or"}=>hash_set
    var parser = new parsergen.repl_parser_type
    var code_buff = new array
    var stages = new array
    var log = false
    function find_first_stage(parser)
        foreach it in parser.stack
            link name = it.product.root
            if !syntax_stages.exist(name)
                return name
            end
        end
    end
    function repl_hook(parser)
        if !parser.eof()
            return parsergen.parse_state.accept
        end
        if stages.size > 0
            var tokens = null
            loop
                tokens = this.readline()
            until tokens != null
            foreach it in tokens do parser.lex.push_back(it)
        end
        return parsergen.parse_state.accept
    end
    function on_eof_hook(parser)
        if log
            system.out.println("Parsing stages:")
            foreach it in parser.stack
                system.out.println("-> " + it.product.root)
            end
            system.out.println("")
        end
        stages.push_front(find_first_stage(parser))
        var tokens = null
        loop
            tokens = this.readline()
        until tokens != null
        foreach it in tokens do parser.lex.push_back(it)
        return true
    end
    function accept_hook(parser)
        if !stages.empty() && find_first_stage(parser) == stages.front
            stages.pop_front()
        end
    end
    function initialize()
        ecs_parser.grammar.stx.stmts = ecs_parser.grammar.stx.stmts_repl
        ecs_parser.repl_hook = repl_hook
        parser.on_eof_hook = on_eof_hook
        parser.accept_hook = accept_hook
    end
    function readline()
        foreach i in range(stages.size + 1) do system.out.print(">")
        system.out.print(" ")
        var line = system.in.getline() + "\n"
        if line == "@exit\n"
            system.exit(0)
        end
        var lexer = new parsergen.lexer_type
        var tokens = lexer.run(ecs_parser.grammar.lex, line)
        if !lexer.error_log.empty()
            parsergen.print_error("<REPL>", code_buff, lexer.error_log)
            return null
        else
            return tokens
        end
    end
    function run()
        parser.log = log
        loop
            var tokens = null
            loop
                tokens = this.readline()
            until tokens != null
            if parser.run(ecs_parser.grammar.stx, tokens)
                var ast = parser.production()
                if ast != null
                    compress_ast(ast)
                    parsergen.print_ast(ast)
                end
            else
                var err = parser.get_log(0)
                parsergen.print_error("<REPL>", code_buff, err)
            end
        end
    end
end

var instance = new repl
instance.log = true
instance.run()